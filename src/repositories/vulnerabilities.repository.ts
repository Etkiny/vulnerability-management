import { Vulnerabilities } from '../entities';
import { Postgres } from '../database';
import { QueryTypes, Op, Sequelize } from 'sequelize';
import { date as dateHelper } from 'helpers';

class VulnerabilityRepository {
    private sequelize = Postgres.getSequelizeInstance();

    async getVulnerability(vulnerabilityId: number): Promise<Vulnerabilities | null> {
        return Postgres.entities.vulnerabilities.findByPk(vulnerabilityId);
    }

    async bulkUpsertVulnerabilities(vulnerabilities: Partial<Vulnerabilities>[]): Promise<void> {
        try {
            const values = vulnerabilities
                .map((v) => {
                    const cveId = v.cveId ?? 'unknown';
                    const description = (v.description ?? 'No description available').replace(/'/g, "''");
                    const publishedDate = v.publishedDate?.toISOString() ?? new Date().toISOString();

                    return `('${cveId}', '${description}', '${publishedDate}', NOW(), NOW())`;
                })
                .join(', ');

            const upsertQuery = `
            INSERT INTO "Vulnerabilities" ("cveId", "description", "publishedDate", "createdAt", "updatedAt")
            VALUES ${values}
            ON CONFLICT ("cveId") DO UPDATE
            SET "description" = EXCLUDED."description",
                "publishedDate" = EXCLUDED."publishedDate",
                "updatedAt" = NOW();
        `;

            await Postgres.query(upsertQuery, { type: QueryTypes.INSERT });
        } catch (error) {
            console.error('Error in bulkUpsert:', error);
            throw new Error('Error in bulkUpsert:');
        }
    }

    async deleteOldVulnerabilities(): Promise<void> {
        try {
            const thirtyDaysAgo = dateHelper.nowDate().subtract(30, 'days').startOf('day').toDate();

            await Postgres.entities.vulnarabilityNotificationHistory.destroy({
                where: {
                    vulnerabilityId: {
                        [Op.in]: Sequelize.literal(
                            `(SELECT id FROM "Vulnerabilities" WHERE "publishedDate" < '${thirtyDaysAgo.toISOString()}')`
                        )
                    }
                }
            });

            await Postgres.entities.vulnerabilities.destroy({
                where: {
                    publishedDate: {
                        [Op.lt]: thirtyDaysAgo
                    }
                }
            });
        } catch (error) {
            console.error('Error in deleteoldVulnerabilities:', error);
            throw new Error('Error in deleteoldVulnerabilities:');
        }
    }

    async getRecentVulnerabilities(): Promise<Vulnerabilities[]> {
        const today = dateHelper.nowDate().startOf('day').toDate();

        return Postgres.entities.vulnerabilities.findAll({
            where: {
                createdAt: {
                    [Op.gte]: today
                }
            }
        });
    }

    async getVulnerabilityByCveId(cveId: string): Promise<Vulnerabilities | null> {
        return Postgres.entities.vulnerabilities.findOne({ where: { cveId } });
    }

    async getVulnerabilitiesByProduct(productName): Promise<Vulnerabilities[]> {
        try {
            const vulnerabilities = await Postgres.entities.vulnerabilities.findAll({
                where: {
                    description: {
                        [Op.like]: `%${productName}%`
                    }
                }
            });
            return vulnerabilities;
        } catch (error) {
            console.error('Error in VulnerabilityRepository.getVulnerabilitiesByProductName:', error);
            throw new Error('Error fetching vulnerabilities');
        }
    }
}

export default new VulnerabilityRepository();
