import path from 'path';
import { Sequelize } from 'sequelize-typescript';
import { QueryOptions } from 'sequelize/lib/dialects/abstract/query-interface';
import { SyncOptions } from 'sequelize/lib/sequelize';
import { Users } from '../entities/users.entity';
import { Products } from '../entities/products.entity';
import { userProductMap } from '../entities/userProductMap.entity';
import { Vulnerabilities } from '../entities/vulnerabilities.entity';
import { vulnarabilityNotificationHistory } from '../entities/vulnarabilityNotificationHistory.entity';

class Postgres {
    private static DB: Sequelize;
    private config;
    public static entities;
    private domain;

    static getTransaction = () => Postgres.DB.transaction();

    static rawQuery = (query: string, options?: QueryOptions) => Postgres.DB.query(query, options);

    setDomain(domain) {
        this.domain = domain;
        return this;
    }

    setConfig(config) {
        this.config = config;
        return this;
    }

    private createDB = () =>
        new Sequelize({
            host: this.config.HOSTNAME,
            username: this.config.USERNAME,
            password: this.config.PASSWORD,
            database: this.config.SCHEMA,
            dialect: 'postgres',
            pool: {
                max: this.config.OPTIONS.MAX_CONNECTION,
                min: this.config.OPTIONS.MIN_CONNECTION,
                idle: this.config.OPTIONS.IDLE_TIME
            },
            logging: this.config.OPTIONS.LOGGING || false,
            benchmark: this.config.OPTIONS.BENCHMARK || false,
            models: [Users, Products, userProductMap, vulnarabilityNotificationHistory, Vulnerabilities],
            modelMatch: (filename, member) => {
                return filename.substring(0, filename.indexOf('.entity')).toLowerCase() === member.toLowerCase();
            },
            repositoryMode: true,
            dialectOptions: {
                decimalNumbers: true
            },
            timezone: 'Europe/Istanbul'
        });

    async initializeDB(sync?: boolean, syncOptions?: SyncOptions) {
        Postgres.DB = this.createDB();

        try {
            await Postgres.DB.authenticate();
            this.setEntities();
            console.log('DB is authenticated!');

            if (sync) {
                await Postgres.DB.sync(syncOptions);
                console.log('DB Sync COMPLETED');
            }
        } catch (err) {
            console.log('DB cannot be authenticated or synchronized!', err);
        }
    }

    private setEntities() {
        switch (this.domain) {
            case 'vulnerability-management':
                this.getRepositories();
                break;
        }
    }

    private getRepositories() {
        Postgres.entities = {
            users: Postgres.DB.getRepository(Users),
            products: Postgres.DB.getRepository(Products),
            userProductMap: Postgres.DB.getRepository(userProductMap),
            vulnerabilities: Postgres.DB.getRepository(Vulnerabilities),
            vulnarabilityNotificationHistory: Postgres.DB.getRepository(vulnarabilityNotificationHistory)
        };
    }

    static getSequelizeInstance(): Sequelize {
        return Postgres.DB;
    }

    static get query() {
        return Postgres.DB.query.bind(Postgres.DB);
    }
}

export { Postgres };
